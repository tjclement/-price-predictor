#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Backbone Author (KICKSTARTER): Ben
KICKSTART DATE: 12 March
SCOPE: Heuristically optimizes the hyperparameters of a given model (i. e. LSTM). This causes exponential time reduction
in comparison to holistic (grid) search of model space.

Toy example problem (for hyperparameter tuning) that is solved in here for pedagogics:
10 * a - 3 * b + 2 * c - 29 = 0
10 * 2 - 3 * 3 + 2 * 9 - 29 = 20 - 9 + 18 - 29 = 11 - 11 = 0
    Search problem: find a solution (a, b, c) for this problem, we know that there is definitely a solution in the
    restricted search space given by our allele pool for each gene, namely (2, 3, 9).

It is suppossed to evolve elitearian (as we are more interested in great candidate solution) than a mean good solution.
This is also reflected in the time series of the mean.fit and max.fit values, where abs(mean.fit) does not gradually
decrease.
"""

# IMPORTS
import random as rnd
import time
import numpy as np

# CONSTANTS
START_TIME = time.time()
GENOME = [range(10), range(10), range(10)] # GENOME = [], ALLELE = [[]], search space (model space), gene pool per allele
POPULATION_SIZE = 10 # let's use 30 at the end, then choose 10 from top ranked, 5 randomly, for mating pool
MUT_PROB = 1 # mutation probability, in current version the probabilty of re-sampling from allowed allele pool
MUT_SW = 3 # maximum mutation stepwidth
MATING_POPULATION_FRACTION = 0.4 # fraction of POPULATION that is allowed to pass on genetic information
LUCKY_FRACTION = 0.2 # fraction of MATING_POPULATION_FRACTION that is not chosen based on their high fitness value
OFFSPRING_PER_COUPLE = 2 # (fertility) kids that are generated by the same daddy and mommy 2-tuple ('2-couple')
# idea: currently 0.5 survivors are used (that live on in next generation without modification) (slow down convergence)
GENERATIONS = 10

# VARIABLES (for pedagogic purpose)
matings = int((POPULATION_SIZE - POPULATION_SIZE * MATING_POPULATION_FRACTION) / OFFSPRING_PER_COUPLE)
    # amount of matings (reproductions) that have to take place


# FUNCTION DEFINITIONS
def create_population(count):
    """
    Creates a random population.
    :param count: (int) amount of candidates
    :return: (np.array) rows are candidates, cols are alleles at position, col 0 is for fitness score (None for missing)
    """
    population = []
    for a in range(count):
        candidate = [None] # for fitness score (yet undetermined)
        for gene in GENOME:
            candidate.append(gene[rnd.randint(0, len(gene) - 1)])
        population.append(candidate)

    return np.array(population)


def mutate(candidate, mutation_probability = MUT_PROB, mutation_stepwidth = MUT_SW):
    """
    Takes the genome of a candidate and mutates it at every position.
    :param candidate: (list) genome of candidate
    :param mutation_probability: (float) probability of mutation at all positions (separately), [0.00 - 1.00]
    :param mutation_stepwidth: (int) in case of mutation, an allele is uniformly statistically chosen this stepwidth
        around the current allele (this assumes that the alleles in the gene pool list are inherently ordered and of
        course does not contain duplicate items
    :return: (list) mutated genome of candidate
    """
    mutated_candidate = [candidate[0]]
    candidate = candidate[1:] # chop fitness score off
    for a in range(0, len(candidate)):
        if float(rnd.randint(1, 100))/100. <= mutation_probability:
            pos = [x for x, y in enumerate(GENOME[a]) if y == candidate[a]][0] # position in allele pool for current gene
            allele_pool = GENOME[a][max([pos - mutation_stepwidth, 0]):min([pos + mutation_stepwidth + 1, len(GENOME[a])])]
            """
            allele_pool = GENOME[a][max([pos-mutation_stepwidth,0]):pos] + \ # version if mutation is enforced
                          GENOME[a][pos+1:min([pos+mutation_stepwidth+1,len(GENOME[a])])]
            """
            mutated_candidate.append(allele_pool[rnd.randint(0, len(allele_pool) - 1)])
        else:
            mutated_candidate.append(candidate[a])
    return np.array(mutated_candidate)
    # stimulation: mutation_probability can be decreased over time (see: learning rate)


def cross(mommy, daddy):
    """
    Bisexual reproduction. Sex of the reproduction partners is randomly assigned on-line. 2 new candidate individuals
    (babies) are generated. Alleles are inherited independently and with equal probability (0.5) from either parent.
    :param mommy: (list) candidate, female reproduction partner
    :param daddy: (list) candidate, male reproduction partner
    :return: (list of lists) 2 new candidates (babies)
    """
    babies, mommy, daddy = [], mommy[1:], daddy[1:] # initialize babies collector, chop fitness score off
    for a in range(2):
        candidate = [None] # yet unknown
        for b in range(len(GENOME)):
            candidate.append(mommy[b] if rnd.randint(0, 1) == 0 else daddy[b])
        babies.append(mutate(candidate)) # a mutated baby
    return np.array(babies)
    # stimulation: probability of inheritance can be biased towards the fitter parent over time (see: learning rate)


def fitness_function(candidate):
    """
    Loss function is applied (using problem 10 * a - 3 * b + 2 * c - 29 = 0). Fitness score is returned. High score
    indicates high fitness (small loss). This is basically phenotype mapping with subsequent determination of a numerical
    difference between candidate phenotype and optimal phenotype (set by environment = objective function).
    :param candidate: candidate vector without first col (fitness score)
    :return: fitness score (float)
    """
    loss = abs(10 * candidate[0] - 3 * candidate[1] + 2 * candidate[2] - 29)
    return -loss


def fitness_rank(population):
    """
    Takes a list of lists (population) and re-orders this list row-wise form fittest to weakest.
    :param population: (list of lists) all candidates
    :return: (np.array) the ranked population with same dimensions (so the fitness score column is removed again)
    """
    # currently this is only a test version, so the fitness-value assigned will be just a random integer
    for candidate in (population):
        if candidate[0] == None:
            candidate[0] = fitness_function(candidate[1:]) # should be a function of the candidate genome (phenotype mapping)
    return population[population[:, 0].argsort()[::-1]]
    # idea: currently sorting is based on first col (fitness score), however sorting conflicts are resolved by taking
    #   values from other cols into consideration (with col order), so that for gene-A a particular allele is favored -
    #   this can be solved by modifying the sorting algorithm, so that conflicts are resolved in a random fashion


def extract_lovers(_ranked_population, lucky_frac=LUCKY_FRACTION, population_size=POPULATION_SIZE, \
                   frac=MATING_POPULATION_FRACTION):
    """
    Extracts the mating (lovers) population. One part is just based on top-ranked candidates, the other part on randomly
    chosen ones from the remainder (to slow down the convergence (evolutionary pressure) and increase chance of finding
    global optimum).
    :param _ranked_population: np.array of candidates ranked row-wise by fitness score
    :param lucky_frac: fraction of mating pool that should be constituted by lucky folks (random from remainder)
    :param population_size: nomen est omen
    :param frac: mating population fraction
    :return: np.array (2D) of mating pool
    """
    mating_population_size = int(population_size * frac)

    # check if mating pool fraction gives an integer amount of maters for the chosen population size
    if int(population_size * frac) - population_size * frac > 0.000001:
        print('Warning in extract_lovers(), frac')

    number_of_lucky_ones = int(mating_population_size * lucky_frac)

    # check if lucky_frac gives an integer amount of maters for the given mating population size
    if int(mating_population_size * lucky_frac) - population_size * frac > 0.000001:
        print('Warning in extract_lovers(), lucky_frac')

    number_of_highest_rankers = mating_population_size - number_of_lucky_ones

    lucky_indices = rnd.sample(range(number_of_highest_rankers,len(_ranked_population)), number_of_lucky_ones)

    mating_population = np.concatenate((_ranked_population[:number_of_highest_rankers, :], \
                                        _ranked_population[lucky_indices, :]), axis=0)
    return mating_population

def custom_display(population):
    """
    Print overview over population and specific fitness cores and prints it to console.
    :param population: np.array
    :return: None
    """
    print('fit\ta\tb\tc')
    for row in population:
        print('\t'.join(map(str, row)))


def main():
    # create (fitness ranked) initial population of candidate solution
    ranked_population = fitness_rank(create_population(POPULATION_SIZE))
    print('Initial population (mean fitness: %.2f):' % np.mean(ranked_population[:, 0]))
    custom_display(ranked_population)

    print ('\ngen\tmean.fit\tmax.fit')

    for a in range(0, GENERATIONS):
        # extract the mating population from the ranked_population
        mating_population = extract_lovers(ranked_population) # contains additional col (0) with scores

        # remove all non-mating candidates from the population
        population = mating_population # contains additional col (0) with scores

        # mating and mutation
        for b in range(matings):
            mommy_index = rnd.randint(0, len(mating_population)-1)
            daddy_index = rnd.randint(0, len(mating_population)-1)
            # make sure mating is sexual
            while daddy_index == mommy_index:
                daddy_index = rnd.randint(0, len(mating_population)-1)
            x = cross(mating_population[mommy_index], mating_population[daddy_index])
            population = np.append(population, x, axis=0)

        # determine fitness of each candidate solution and rank the population based on it row-wise
        ranked_population = fitness_rank(population) # contains additional col (0) with scores

        # on-line output for user-information
        print('%i\t%.2f\t%.2f' % (a, np.mean(population[:, 0]), max(population[:, 0])))

    # output of final fitness ranked population
    population = fitness_rank(population)
    print('\nFinal population after %i generations of evolution (mean fitness: %.2f):' % (GENERATIONS, \
                                                                                        np.mean(population[:, 0])))
    custom_display(population)

    print('Script was successfully executed in %.8s s.' % (time.time() - START_TIME))

# SCRIPT EXECUTION
if __name__ == '__main__':
    main()


# END OF FILE